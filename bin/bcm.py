#!/usr/bin/env python
"""
bcm.py
========

Objective : opticks-config
----------------------------

Need to build against opticks without using CMake in a manner that 
can be integrated with anything, for example CMT. For this 
need an opticks-config script that can provide for each target and external 
its libs and cflags.  

1st Thoughts : parse CMake BCM tea-leaves
-------------------------------------------

Original approach of parsing BCM tealeaves is reinventing the CMake wheel.
Instead use CMake introspection, similarly to what BCM does (initially in 
an extension to BCM deploy_targets?) 
to generate json metadata that describes all targets 
and externals and their dependencies.  
This way are getting the information direct from 
CMake, so it will be less fragile and more general.

CMake has all the information, so it is crazy not to directly use that
to extract the needed info into an easily consumable form. 


2nd Thoughts : oc.bash oc.py
-------------------------------

Dependencies and config information does not change very quickly 
and they are not that complicated so the automation reflex is misplaced.
The effort saved by the automation does not justify the effort expended, 
which is considerable as CMake does not make this kind of thing easy.
Instead pursue a manual approach in ~/opticks/oc.bash which is 
being tested in ~/opticks/examples/UseXXXNoCMake examples such 
as UseNPYNoCMake.


3rd Thoughts : pkg-config
---------------------------

Many pkg-config .pc files are already being generated from CMake/BCM, 
just need to shake those down. 

Investigation notes in env/pkg-config-


What about RPATH ?
--------------------

See cmake/Modules/OpticksBuildOptions.cmake on RPATH setup to use the
ORIGIN trick so that opticks binaries can find their libs without 
crutches like LD_LIBRARY_PATH::

   CMAKE_INSTALL_RPATH "$ORIGIN/../lib64:$ORIGIN/../externals/lib:$ORIGIN/../externals/lib64:$ORIGIN/../externals/OptiX/lib64"

Could that be extended to JUNO ?

* probably not, CMT largely based on LD_LIBRARY_PATH


CMake introspection
--------------------

* https://stackoverflow.com/questions/37434946/how-do-i-iterate-over-all-cmake-targets-programmatically

Original Overcomplicated Approach
--------------------------------------

Attempt to parse the CMake/BCM tealeaves in order to 
provide the config information that CMake would 
without using CMake.


* hmm this works fine for the lib64/cmake exported targets, 
  but extracting things from the hand written cmake/Modules
  which are "installed" by okdist--
  is going to be painful and fragile

* maybe can used bcm_deploy to cast those 
  into the standard exported form and parse that ?

  * seems confusing and overcomplicated to do this, 
    plus its depending on my fork of BCM a bit too much 


Actually the critical parts of the FindXXX.cmake are mostly the same::

     20 find_path(
     21     PLog_INCLUDE_DIR 
     22     NAMES "plog/Log.h"
     23     PATHS "${OPTICKS_PREFIX}/externals/plog/include"
     24 )

* implementing a python equivalent that finds the path seems easy enough, 
  but some are complicated like XercesC


The exported targets are all generated by BCM, so they 
should strictly follow patterns.


Inclusion tree of BCM exported targets::

    lib64/cmake/extg4/extg4-config-version.cmake
        just version setup

    lib64/cmake/extg4/extg4-config.cmake
           
        lib64/cmake/extg4/extg4-targets.cmake
             lib64/cmake/extg4/extg4-targets-debug.cmake

        lib64/cmake/extg4/properties-extg4-targets.cmake


properties all have same pattern
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

    [blyth@lxslc701 lib64]$ find . -name properties-*.cmake -exec cat {} \;

    set_target_properties(Opticks::OKOP PROPERTIES INTERFACE_PKG_CONFIG_NAME okop)

    set_target_properties(Opticks::YoctoGLRap PROPERTIES INTERFACE_PKG_CONFIG_NAME yoctoglrap)

    ...


"""

import os, re, logging, sys, argparse
log = logging.getLogger(__name__)

import StringIO, textwrap
from collections import OrderedDict as odict
from ConfigParser import ConfigParser

class Cfg(object):
    def __init__(self, txt):
        sfp = StringIO.StringIO(txt)
        c = ConfigParser()
        c.readfp(sfp)
        self.c = c 
        self.d = self.full(c) 

    def full(self, c):
        d = odict()
        for s in c.sections(): 
            d[s] = dict(c.items(s))
        pass  
        return d

    def sections(self):
        return self.c.sections()

    def sect(self, s):
        return dict(self.c.items(s))

    def __repr__(self):
        return "\n".join(["%s\n%s" % (k,repr(v)) for k, v in self.d.items()])




class CMakeTargets(object):
    """
    # Create imported target Opticks::SysRap
    add_library(Opticks::SysRap SHARED IMPORTED)

    set_target_properties(Opticks::SysRap PROPERTIES
      INTERFACE_COMPILE_DEFINITIONS "OPTICKS_SYSRAP"
      INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include/SysRap"
      INTERFACE_LINK_LIBRARIES "Opticks::PLog;Opticks::OKConf;ssl;crypto"
    )
    """ 
    pass

    HEAD_STP = re.compile("^set_target_properties\((?P<lib>\S*)\s*PROPERTIES\s*$")
    BODY_STP = re.compile("\s*(?P<key>\S*)\s*\"(?P<val>\S*)\"\s*$") 
    TAIL_STP = re.compile("^\s*\)\s*$")

    HEAD_PFX = 'get_filename_component(_IMPORT_PREFIX "${CMAKE_CURRENT_LIST_FILE}" PATH)'
    BODY_PFX = 'get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)' 


    def __init__(self, paths ):
        self.paths = paths
        self.targets = {}
        for path in paths:
            self.parse_targets(path) 
        pass 

    def parse_targets(self, path):
        log.debug("parse_targets %s " % path) 
        lib = None
        props = {}
        prefix = None
 
        for line in file(path, "r").readlines():

            mhpfx = line.startswith(self.HEAD_PFX)
            mbpfx = line.startswith(self.BODY_PFX)

            if mhpfx:
                prefix = os.path.dirname(path)
            elif mbpfx:
                assert not prefix is None
                prefix = os.path.dirname(prefix)
            pass    

            mhead = self.HEAD_STP.match(line)  
            mbody = self.BODY_STP.match(line)  
            mtail = self.TAIL_STP.match(line)  

            if mhead:
                lib = mhead.groupdict()["lib"]
                if not prefix is None:
                    self.prefix = prefix 
                pass
                #print("lib  %s prefix %s  " % (lib, self.prefix))
            elif mbody and not lib is None:
                d = mbody.groupdict()
                key, val = d["key"], d["val"]
                #print( "key %s val %s prefix %s " % (key, val, prefix))
                if not self.prefix is None:
                    val = val.replace("${_IMPORT_PREFIX}", self.prefix) 
                pass
                props[key] = val 
            elif mtail:
                assert not lib is None
                log.debug("parse_targets lib %s props %s " % (lib, repr(props)))
                self.targets[lib] =  props.copy() 
                props.clear()
                lib = None
            else:
                pass
            pass 
        pass

    def __repr__(self):
        return repr(self.targets) 
 



class TopMeta(object):
    BEG = re.compile("\#\[=\[ TOPMETA (?P<name>\S*)\s*$")
    END = "#]=]"

    def __init__(self, path):
         self.ini = self.parse_topmeta(path)
   
    def parse_topmeta(self, path):
        log.debug("parse_topmeta %s " % path) 
        idx = -1 
        lines = []
        name = None
        ini = {}

        for line in file(path, "r").readlines():
            #print(line)
            bmat = self.BEG.match(line) 
            if bmat:
                name = bmat.groupdict()["name"] 
                idx = 0 
            elif line.startswith(self.END):
                idx = -1
                assert not name is None
                ini[name] = "\n".join(lines)
                lines[:] = []
            elif idx > -1:
                idx += 1
            else:
                pass
            pass  
            if idx > 0:
               lines.append(line[:-1])
            pass
        pass
        return ini 


    def __repr__(self):
        return "\n".join([repr(self.ini.keys())])





class CMakeConfig(object):
    """

    CMakeConfig
    ------------
   
    Parses files generated by BCM with names like <pfx>-config.cmake where
    pfx are package prefixes such as okop.


    /usr/local/opticks/lib/cmake/okop/okop-config.cmake::

        # TOPMATTER

        include(CMakeFindDependencyMacro)
        # Library: Opticks::OptiXRap
        find_dependency(OptiXRap)

        include("${CMAKE_CURRENT_LIST_DIR}/okop-targets.cmake")
        include("${CMAKE_CURRENT_LIST_DIR}/properties-okop-targets.cmake")

    """

    LIB = re.compile("^# Library: (?P<lib>\S*)\s*$")
    DEP = re.compile("^find_dependency\((?P<dep>.*)\)\s*$")

    def __init__(self, path, pfx):
        """
        :param path:
        :param pfx:

        parsed TOPMETA for externals doesnt belong inside a sub, 
        it should be regarded as referenced from a sub : but have its 
        own external collection
        """
        assert os.path.exists(path) 
        self.path = path 
        self.pfx = pfx
        self.parse_config(path)  # collects libs and deps


        targets_path = path.replace("-config.cmake","-targets.cmake")
        targets_debug_path = path.replace("-config.cmake","-targets-debug.cmake")

        
        tpaths = [] 
        if os.path.exists(targets_path):
            tpaths.append(targets_path)
        pass 
        if os.path.exists(targets_debug_path): 
            tpaths.append(targets_debug_path)
        pass 
        # assimp using non-BCM manual CMake export 
        targets = CMakeTargets(tpaths)

        self.topmeta = TopMeta(path)
        self.externals = self.topmeta.ini.keys()
 

    def parse_config(self, path):
        """
        :param path:

        Collects lists of libraries eg OptiXRap and dependencies
        """
        libs = []
        deps = []

        log.debug("parse_config %s " % path) 
        for line in file(path, "r").readlines():
            mlib = self.LIB.match(line)
            mdep = self.DEP.match(line)
            if mlib:
                lib = mlib.groupdict()["lib"]
                log.debug("lib %s " % lib) 
                assert lib.startswith("Opticks::") or lib.startswith("Boost::"), lib
                lib = lib.split("::")[1] 
                libs.append(lib)
            if mdep:
                dep = mdep.groupdict()["dep"]
                log.debug("dep %s " % dep) 
                deps.append(dep.replace(" ","_"))
            pass 
        pass   
        assert len(libs) == len(deps)
        self.libs = libs
        self.deps = deps   # find_dependency tee-d up

    def __repr__(self):
        return "%s : %s : %s " % ( self.pfx, " ".join(self.libs), " ".join(self.externals) ) 
 

class Targets(dict):
    def __init__(self):
        dict.__init__(self)

class Externals(dict):
    def __init__(self):
        dict.__init__(self)



class CMakeInstall(object):
    """ 
    Encompasses all the installed metadata of internal subprojs and externals
    as gleaned from parsing the CMake exported targets, including the 
    TOPMETA from externals  
    """
    CONFIG = re.compile("(?P<pfx>\S*)-config.cmake")
    def __init__(self, bases, sub):
        """
        :param bases: colon delimited list of directories to be searched for cmake metadata 
        :param sub: usually None, allows restricting directories to search 
                    during development with "--sub" argument

        * collects a list of directories to search, using the supplied bases and checking existance
        * finds exported targets recursively collecting results into two string keyed dict subclasses::

          self.externals 
          self.targets 

        """
        paths = [] 
        for base in bases:
            path = os.path.join(*filter(None,[base, sub])) 
            if not os.path.isdir(path): continue
            paths.append(path)  
        pass
        self.paths = paths
        self.targets = Targets()  
        self.externals = Externals()
        self.find_exported_targets() 

    def find_exported_targets(self):
        for path in self.paths: 
            self.find_exported_targets_r(path, 0) 
        pass 

    def find_exported_targets_r(self, base, depth ):
        """
        :param base: directory 
        :param depth: integer

        * recursively searches directories starting from base for 
          files matching <pfx>-config.cmake, names being parsed 
          to give pfx, eg okop

        * such config files are parsed with class CMakeConfig
         

        find /usr/local/opticks/externals/lib64 -name '*-config.cmake'
        find /usr/local/opticks/lib -name '*-config.cmake'


        """
        assert os.path.isdir(base), "expected directory %s does not exist " % base
        log.debug("FIND_EXPORTED_TARGETS_R base %s depth %s " % (base, depth))
        names = os.listdir(base)
        for name in names:
            path = os.path.join(base, name)
            if os.path.isdir(path):
                self.find_exported_targets_r(path, depth+1)
            else:
                m = self.CONFIG.match(name)
                if not m: continue
                pfx = m.groupdict()['pfx']
                pass
                exported_targets = CMakeConfig(path, pfx) 
                pass 
                for name in exported_targets.externals:  # collect TOPMETA for externals
                    cfg = Cfg(exported_targets.topmeta.ini[name]) 
                    cfg.path = path 
                    cfg.name = name
                    cfg.deps = []
                    self.externals[name.lower()] = cfg
                pass
                self.targets[pfx] = exported_targets
            pass
        pass

    def get_target(self, pfx):
        assert pfx in self.targets
        return self.targets[pfx]     

    def get_external(self, x):
        assert x in self.externals
        return self.externals[x]     

    def query(self, q ):
        """
        :param q: subname (eg okconf, sysrap) or external name (eg GLM, OptiX) 
        :return r: 
        """
        rt = self.target(q)
        rx = self.external(q)

        if rt and rx:
            assert False, (rt, rx, "both target and external ?") 
            r = None
        elif rt:
            r = rt  
        elif rx:
            r = rx  
        else:
            r = None
        pass
        return r

    def rquery(self, q ):
        rr = []
        def query_r(q, depth):
            r = self.query(q)

            log.info(" q %s r %s depth %s " % (q, repr(r), depth))  

            if r is None:
                log.info("r None for q %s " % q)
                return
            pass  

            if not r in rr:
                rr.append(r)
            pass
            for d in r.deps:
                query_r(d, depth+1)
            pass
        pass
        query_r(q, 0)
        return rr 

    def external(self, x ):
        if x.lower() in self.externals:
            r = self.get_external(x.lower()) 
        else: 
            r = None
        pass
        return r

    def target(self, t ):
        if t in self.targets:
            r = self.get_target(t) 
        elif t.lower() in self.targets:
            r = self.get_target(t.lower()) 
        else: 
            r = None
        pass
        return r


    def dump_targets(self):
        return "\n".join(map(repr, self.targets.values()))  

    def dump_externals(self):
        return "\n".join(map(repr, self.externals.values()))  

    def __repr__(self):
        return "\n".join(map(repr, self.targets.values() + self.externals.values() ))  



    @classmethod
    def ParseArgs(cls):
        """
        See man pkg-config

        --cflags
        --libdir
        --libs 
        ...
        """ 
        parser = argparse.ArgumentParser(__doc__)
        bases = "$OPTICKS_INSTALL_PREFIX/lib/cmake:$OPTICKS_INSTALL_PREFIX/externals/lib/cmake"
        parser.add_argument( "--bases", default=bases, help="Possibly colon delimited list of directories containing the exported CMake targets, eg $OPTICKS_INSTALL_PREFIX/lib64/cmake" ) 
        parser.add_argument( "--sub", default=None, help="Base relative directory to restrict parsing during development.")
        parser.add_argument( "--level", default="info", help="logging level" ) 
        parser.add_argument( "-q", "--query", default=None, help="Query target or external" )
        parser.add_argument( "-x", "--external", default=None, help="Query external" )
        parser.add_argument( "-t", "--target",  default=None, help="Query target" )
        parser.add_argument( "-d", "--dump",  default=False, action="store_true", help="Dump all targets and externals" )
        parser.add_argument( "-T", "--dumptargets",  default=False, action="store_true", help="Dump all targets" )
        parser.add_argument( "-X", "--dumpexternals",  default=False, action="store_true", help="Dump all externals" )
        parser.add_argument( "-p", "--path",  default=False, action="store_true", help="Show path of source files" )
        parser.add_argument( "-r", "--recursive",  default=False, action="store_true", help="Recursively follow query dependencies" )
        args = parser.parse_args()
        fmt = '[%(asctime)s] p%(process)s {%(pathname)s:%(lineno)d} %(levelname)s - %(message)s'
        logging.basicConfig(level=getattr(logging,args.level.upper()), format=fmt)
        return args 

    @classmethod
    def Main(cls):
        args = cls.ParseArgs() 
        bases = map(lambda _:os.path.expandvars(_), args.bases.split(":"))
        cmi = CMakeInstall(bases, args.sub)    
        if args.dump:
            print(cmi)
            if args.path:
                print(cmi.path)
            pass            
        pass 
        if args.dumptargets:
            print(cmi.dump_targets())
        if args.dumpexternals:
            print(cmi.dump_externals())


        if args.query and args.recursive:
            rr = cmi.rquery(args.query)   
            for i, r in enumerate(rr):
                print("---------------- %d " % i )
                print(r)
                if args.path:
                    print(r.path)
                pass 
            pass 
        elif args.query:
            r = cmi.query(args.query)   
            print(r)
            if args.path:
                print(r.path)
            pass       
        pass 


        if args.external: 
            r = cmi.external(args.external)   
            print(r)
            if args.path:
                print(r.path)
            pass            
        pass 
        if args.target: 
            r = cmi.target(args.target)   
            print(r)
            if args.path:
                print(r.path)
            pass            
        pass


if __name__ == '__main__':
    CMakeInstall.Main()    

